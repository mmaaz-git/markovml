window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "markovml", "modulename": "markovml", "kind": "module", "doc": "<p>This is the documentation for <code>markovml</code>.</p>\n\n<p>The main functionality is contained in the <code>markovml</code> module. It contains three classes: <code>MarkovReward</code>, <code>MarkovReach</code>, and <code>MarkovHitting</code>, which let you analyze the total reward, reachability, and hitting time of a Markov process with learned parameters. They all are based on the <code>AbstractMarkov</code> class, which provides the common functionality for all three classes.</p>\n\n<p>Currently, the following models are supported:</p>\n\n<ul>\n<li><code>sklearn.linear_model.LinearRegression</code></li>\n<li><code>sklearn.linear_model.Ridge</code></li>\n<li><code>sklearn.linear_model.Lasso</code></li>\n<li><code>sklearn.linear_model.LogisticRegression</code></li>\n<li><code>sklearn.tree.DecisionTreeRegressor</code></li>\n<li><code>sklearn.tree.DecisionTreeClassifier</code></li>\n<li><code>sklearn.ensemble.RandomForestRegressor</code></li>\n<li><code>sklearn.ensemble.RandomForestClassifier</code></li>\n<li><code>sklearn.neural_network.MLPRegressor</code></li>\n<li><code>sklearn.neural_network.MLPClassifier</code></li>\n<li><code>markovml.utils.models_ext.DecisionRules</code> -- our custom model for \"if-then\" rules, e.g., \"if age &gt; 65 then 3.0\"</li>\n<li><code>torch.nn.Sequential</code> -- only Linear and ReLU layers are supported</li>\n<li><code>markovml.utils.models_ext.SequentialClassifier</code> -- wrapper around a PyTorch Sequential model that adds a final softmax layer</li>\n</ul>\n\n<p>In the <code>utils</code> module, you can find some utility functions for working with Markov processes. Namely, there are the modules <code>utils.gurobi_ml_ext</code>, <code>utils.models_ext</code>, and <code>utils.ima</code>. The first one extends the Gurobi machine learning functionality to work with additional models, namely classifiers with softmax outputs; the second one contains some additional \"models\" that we have implemented for convenience, namely <code>DecisionRules</code> which allows the user to specify \"if-then\" statements in natural language, and <code>SequentialClassifier</code>, which is a wrapper for a PyTorch <code>nn.Sequential</code> model that adds a softmax layer at the end of it; the third one contains all the functions necessary for <em>interval matrix analysis</em>, culminating in the implementation of the interval version of the Gauss-Seidel method.</p>\n"}, {"fullname": "markovml.markovml", "modulename": "markovml.markovml", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "markovml.markovml.AbstractMarkov", "modulename": "markovml.markovml", "qualname": "AbstractMarkov", "kind": "class", "doc": "<p>This is an abstract class for Markov processes with ML models embedded.\nIt implements all the basic functionality for setting up a Markov process,\nadding ML models, defining the feature space, and optimizing, including\nwith the decomposition and bound propagation scheme from the paper.\nIt will be subclassed by <code>MarkovReward</code>, <code>MarkovReach</code>, and <code>MarkovHitting</code>,\nwhich specialize the functionality to the specific problems.</p>\n", "bases": "abc.ABC"}, {"fullname": "markovml.markovml.AbstractMarkov.__init__", "modulename": "markovml.markovml", "qualname": "AbstractMarkov.__init__", "kind": "function", "doc": "<p>Initialize the Markov process with the given number of states and features.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>n_states</strong> (int):\nNumber of states in the Markov process (<code>n</code> in the paper)</li>\n<li><strong>n_features</strong> (int):\nNumber of features in the Markov process (<code>m</code> in the paper)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>This initializes the basic attributes of the Markov process including:</p>\n\n<ul>\n<li>Number of states and features</li>\n<li>Gurobi optimization model</li>\n<li>Parameter dictionaries for variables, ML output flags, and dimensions</li>\n<li>Feature space variables and constraints</li>\n<li>ML model and output storage</li>\n</ul>\n\n<p>Subclasses will have additional attributes in their constructors.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">n_states</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">n_features</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span>)</span>"}, {"fullname": "markovml.markovml.AbstractMarkov.n_states", "modulename": "markovml.markovml", "qualname": "AbstractMarkov.n_states", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "markovml.markovml.AbstractMarkov.n_features", "modulename": "markovml.markovml", "qualname": "AbstractMarkov.n_features", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "markovml.markovml.AbstractMarkov.model", "modulename": "markovml.markovml", "qualname": "AbstractMarkov.model", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "markovml.markovml.AbstractMarkov.variables", "modulename": "markovml.markovml", "qualname": "AbstractMarkov.variables", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Dict[str, gurobipy._core.Var]"}, {"fullname": "markovml.markovml.AbstractMarkov.features", "modulename": "markovml.markovml", "qualname": "AbstractMarkov.features", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "markovml.markovml.AbstractMarkov.feature_aux", "modulename": "markovml.markovml", "qualname": "AbstractMarkov.feature_aux", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "markovml.markovml.AbstractMarkov.feature_constraints", "modulename": "markovml.markovml", "qualname": "AbstractMarkov.feature_constraints", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "markovml.markovml.AbstractMarkov.ml_models", "modulename": "markovml.markovml", "qualname": "AbstractMarkov.ml_models", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "markovml.markovml.AbstractMarkov.ml_outputs", "modulename": "markovml.markovml", "qualname": "AbstractMarkov.ml_outputs", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "markovml.markovml.AbstractMarkov.get_values", "modulename": "markovml.markovml", "qualname": "AbstractMarkov.get_values", "kind": "function", "doc": "<p>Get values of the key variables of the Markov process after optimization.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.markovml.AbstractMarkov.set_to_ml_output", "modulename": "markovml.markovml", "qualname": "AbstractMarkov.set_to_ml_output", "kind": "function", "doc": "<p>Set a variable to an ML output. Checks if already has been set to an ML output or a constant.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>var</strong> (gp.Var):\nThe variable to set</li>\n<li><strong>expr</strong> (gp.LinExpr | gp.Var):\nThe expression to set the variable to</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>In practice, introduces an equality constraint to the model.</p>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If unknown variable type\nIf the variable is already set to an ML output or a constant</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">var</span><span class=\"p\">:</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">Var</span>,</span><span class=\"param\">\t<span class=\"n\">expr</span><span class=\"p\">:</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">LinExpr</span> <span class=\"o\">|</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">Var</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.markovml.AbstractMarkov.set_to_const", "modulename": "markovml.markovml", "qualname": "AbstractMarkov.set_to_const", "kind": "function", "doc": "<p>Set a variable to a constant value. Checks if already has been set to a constant or an ML output.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>var</strong> (gp.Var):\nThe variable to set</li>\n<li><strong>value</strong> (float | int):\nThe constant value to set the variable to</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>In practice, introduces an equality constraint to the model and fixes\nupper and lower bounds of the variable to the given value.</p>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If unknown variable type\nIf the variable is already set to a constant or an ML output</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">var</span><span class=\"p\">:</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">Var</span>, </span><span class=\"param\"><span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.markovml.AbstractMarkov.add_feature_constraint", "modulename": "markovml.markovml", "qualname": "AbstractMarkov.add_feature_constraint", "kind": "function", "doc": "<p>Add a feature constraint to the model.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>expr</strong> (gp.LinExpr):\nThe linear expression to add as a constraint</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Adds the constraint to the model and also stores it in self.feature_constraints.\nConstraints that are added here are also copied over when optimizing over ML outputs.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">expr</span><span class=\"p\">:</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">LinExpr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.markovml.AbstractMarkov.add_feature_aux_variable", "modulename": "markovml.markovml", "qualname": "AbstractMarkov.add_feature_aux_variable", "kind": "function", "doc": "<p>Add a feature auxiliary variable to the model.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>*args</strong> (tuple):\nArguments to pass to self.model.addVar</li>\n<li><strong>**kwargs</strong> (dict):\nKeyword arguments to pass to self.model.addVar</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>gp.Var</strong>: The auxiliary variable added to the model</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Adds a variable to the model and stores it in self.feature_aux. Variables\nadded here are also copied over when optimizing over ML outputs. Arguments\nare passed to Gurobi's addVar function, so can specify variable types, bounds,\netc. Hence, can encode arbitrary MILP constraints by adding integer auxiliary\nvariables.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.markovml.AbstractMarkov.add_constraint", "modulename": "markovml.markovml", "qualname": "AbstractMarkov.add_constraint", "kind": "function", "doc": "<p>Add an inequality to the overall model.\nCould just call self.model.addConstr(constr), but this is a wrapper for clarity.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>constr</strong> (gp.Constr):\nThe constraint to add</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">constr</span><span class=\"p\">:</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">Constr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.markovml.AbstractMarkov.add_ml_model", "modulename": "markovml.markovml", "qualname": "AbstractMarkov.add_ml_model", "kind": "function", "doc": "<p>Add an ML model to the Markov process. Computes the constraints linking\nthe ML outputs to the features, and creates variables for the ML outputs.\nML outputs can then be accessed using self.ml_outputs.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ml_model</strong> (Any):\nThe ML model to add</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If the ML model type is not supported</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ml_model</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.markovml.AbstractMarkov.optimize", "modulename": "markovml.markovml", "qualname": "AbstractMarkov.optimize", "kind": "function", "doc": "<p>Public interface for optimizing the problem.\nIf use_decomp is True, we use the decomposition and bound propagation approach.\nCan also set the sense, verbosity, and additional Gurobi parameters if needed.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>use_decomp</strong> (bool (default=True)):\nWhether to use the decomposition and bound propagation approach</li>\n<li><strong>sense</strong> (str (default=\"max\")):\nThe sense of the optimization problem, either \"max\" or \"min\"</li>\n<li><strong>verbose</strong> (bool (default=False)):\nWhether to print Gurobi output</li>\n<li><strong>gurobi_params</strong> (dict (default=None)):\nAdditional Gurobi parameters to set, e.g., {'TimeLimit': 60}</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dict</strong>: A dictionary containing the optimization result. Possible formats:</li>\n</ul>\n\n<p>For optimal/suboptimal solutions:\n{\n    'status': str, either 'optimal' or 'suboptimal',\n    'objective': float, the objective value,\n    'values': dict, the values of the variables\n}</p>\n\n<p>For infeasible/unbounded problems:\n{\n    'status': str, either 'infeasible' or 'unbounded',\n    'message': str, description of the problem\n}</p>\n\n<p>For other errors:\n{\n    'status': 'error',\n    'message': str, error description with status code\n}</p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>First checks if all required variables are set, then implements the decomposition\nand bound propagation approach, and lastly solves the bilinear program.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">use_decomp</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">sense</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;max&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">gurobi_params</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.markovml.AbstractMarkov.find_feasible", "modulename": "markovml.markovml", "qualname": "AbstractMarkov.find_feasible", "kind": "function", "doc": "<p>Public interface for finding a feasible solution to the problem.\nIt finds a feasible feature vector.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>lb</strong> (float | int | None (default=None)):\nThe lower bound on the feature vector. None means -inf.</li>\n<li><strong>ub</strong> (float | int | None (default=None)):\nThe upper bound on the feature vector. None means inf.</li>\n<li><strong>use_decomp</strong> (bool (default=True)):\nWhether to use the decomposition and bound propagation approach</li>\n<li><strong>verbose</strong> (bool (default=False)):\nWhether to print Gurobi output</li>\n<li><strong>gurobi_params</strong> (dict (default=None)):\nAdditional Gurobi parameters to set, e.g., {'TimeLimit': 60}</li>\n<li><strong>Returns</strong></li>\n<li><strong>dict</strong>: A dictionary containing the feasibility result. Possible formats:</li>\n</ul>\n\n<p>For feasible solutions:\n{\n    'status': 'feasible',\n    'values': dict, the values of the variables\n}</p>\n\n<p>For infeasible/unbounded problems:\n{\n    'status': str, either 'infeasible' or 'unbounded',\n    'message': str, description of the problem\n}</p>\n\n<p>For other errors:\n{\n    'status': 'error',\n    'message': str, error description with status code\n}</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">lb</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ub</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">use_decomp</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">gurobi_params</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.markovml.AbstractMarkov.get_value", "modulename": "markovml.markovml", "qualname": "AbstractMarkov.get_value", "kind": "function", "doc": "<p>Get value of variable after optimization.\nCan either pass in a Gurobi variable or a string (name of variable).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>var</strong> (gp.Var | str):\nThe variable to get the value of. If a string, it is the name of the variable.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>float</strong>: The value of the variable</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">var</span><span class=\"p\">:</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">Var</span> <span class=\"o\">|</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.markovml.MarkovReward", "modulename": "markovml.markovml", "qualname": "MarkovReward", "kind": "class", "doc": "<p>For the total reward problem.</p>\n", "bases": "AbstractMarkov"}, {"fullname": "markovml.markovml.MarkovReward.__init__", "modulename": "markovml.markovml", "qualname": "MarkovReward.__init__", "kind": "function", "doc": "<p>Initialize a Markov reward process for the total reward problem.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>n_states</strong> (int):\nThe number of states</li>\n<li><strong>n_features</strong> (int):\nThe number of features</li>\n<li><strong>discount_factor</strong> (float (default=0.97)):\nThe discount factor for the Markov process</li>\n<li><strong>pi</strong> (Optional[List | np.ndarray] (default=None)):\nThe initial state probabilities</li>\n<li><strong>P</strong> (Optional[List[List] | np.ndarray] (default=None)):\nThe transition probabilities</li>\n<li><strong>r</strong> (Optional[List | np.ndarray] (default=None)):\nThe reward vector</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Calls the constructor of the parent class AbstractMarkov, and additionally stores\nthe discount factor. Then, initializes the defining parameters and constraints.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n_states</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_features</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">discount_factor</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.97</span>,</span><span class=\"param\">\t<span class=\"n\">pi</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">P</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">r</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "markovml.markovml.MarkovReward.discount_factor", "modulename": "markovml.markovml", "qualname": "MarkovReward.discount_factor", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "markovml.markovml.MarkovReward.get_values", "modulename": "markovml.markovml", "qualname": "MarkovReward.get_values", "kind": "function", "doc": "<p>Returns the values of pi, P, r, v, features, and ml_outputs as a dictionary.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dict</strong>: A dictionary with keys:\n<ul>\n<li><code>pi</code>: the values of pi</li>\n<li><code>P</code>: the values of P</li>\n<li><code>r</code>: the values of r</li>\n<li><code>v</code>: the values of v</li>\n<li><code>features</code>: the values of the features</li>\n<li><code>ml_outputs</code>: the values of the ml_outputs</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.markovml.MarkovReward.pi", "modulename": "markovml.markovml", "qualname": "MarkovReward.pi", "kind": "variable", "doc": "<p>Accessor for the pi parameter.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>gurobipy.tupledict</strong>: The pi parameter</li>\n</ul>\n"}, {"fullname": "markovml.markovml.MarkovReward.P", "modulename": "markovml.markovml", "qualname": "MarkovReward.P", "kind": "variable", "doc": "<p>Accessor for the P parameter.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>gurobipy.tupledict</strong>: The P parameter</li>\n</ul>\n"}, {"fullname": "markovml.markovml.MarkovReward.r", "modulename": "markovml.markovml", "qualname": "MarkovReward.r", "kind": "variable", "doc": "<p>Accessor for the r parameter.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>gurobipy.tupledict</strong>: The r parameter</li>\n</ul>\n"}, {"fullname": "markovml.markovml.MarkovReward.v", "modulename": "markovml.markovml", "qualname": "MarkovReward.v", "kind": "variable", "doc": "<p>Accessor for the v parameter.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>gurobipy.tupledict</strong>: The v parameter</li>\n</ul>\n"}, {"fullname": "markovml.markovml.MarkovReward.set_pi", "modulename": "markovml.markovml", "qualname": "MarkovReward.set_pi", "kind": "function", "doc": "<p>Helper function to set the entire pi vector.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>values</strong> (List[float | int | gp.Var | gp.LinExpr]):\nThe values to set the pi parameter to</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If the values have incorrect length, are not in [0, 1], don't sum to 1,or pi is already set</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>This checks for validity of the values, checks if pi is already set, and sets the values.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">Var</span> <span class=\"o\">|</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">LinExpr</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.markovml.MarkovReward.set_r", "modulename": "markovml.markovml", "qualname": "MarkovReward.set_r", "kind": "function", "doc": "<p>Helper function to set the entire r vector.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>values</strong> (List[float | int | gp.Var | gp.LinExpr]):\nThe values to set the r parameter to</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If the values have incorrect length, or r is already set</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>This checks for validity of the values, checks if r is already set, and sets the values.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">Var</span> <span class=\"o\">|</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">LinExpr</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.markovml.MarkovReward.set_P", "modulename": "markovml.markovml", "qualname": "MarkovReward.set_P", "kind": "function", "doc": "<p>Helper function to set the entire P matrix.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>values</strong> (List[List[float | int | gp.Var | gp.LinExpr]]):\nThe values to set the P parameter to</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If the values have incorrect shape, are not in [0, 1], rows don't sum to 1, or P is already set</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>This checks for validity of the values, checks if P is already set, and sets the values.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">Var</span> <span class=\"o\">|</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">LinExpr</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.markovml.MarkovReward.add_ifr_inequalities", "modulename": "markovml.markovml", "qualname": "MarkovReward.add_ifr_inequalities", "kind": "function", "doc": "<p>Helper function to add IFR (increasing failure rate) inequalities on P.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The definition of IFR is the following. Given an $n \\times n$ transition matrix $P$, and a fixed $i \\in [n]$,\ndefine the function $b_h(i) = \\sum_{j=h}^n P_{ij}$. Then, $P$ is IFR if, for each $h \\in [n]$, we have\n$b_h(i) \\leq b_h(i+1)$ for all $i \\in [n-1]$.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.markovml.MarkovReach", "modulename": "markovml.markovml", "qualname": "MarkovReach", "kind": "class", "doc": "<p>For the reachability problem.</p>\n", "bases": "AbstractMarkov"}, {"fullname": "markovml.markovml.MarkovReach.__init__", "modulename": "markovml.markovml", "qualname": "MarkovReach.__init__", "kind": "function", "doc": "<p>Initialize a Markov chain for the reachability problem.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>n_states</strong> (int):\nThe number of states</li>\n<li><strong>n_features</strong> (int):\nThe number of features</li>\n<li><strong>n_targets</strong> (int):\nThe number of target states ($|S|$ in the paper)</li>\n<li><strong>n_transient</strong> (int):\nThe number of transient states ($|T|$ in the paper)</li>\n<li><strong>pi</strong> (Optional[List | np.ndarray]):\nThe initial state distribution over transient states</li>\n<li><strong>Q</strong> (Optional[List[List] | np.ndarray]):\nThe transition matrix between transient states</li>\n<li><strong>R</strong> (Optional[List[List] | np.ndarray]):\nThe transition matrix from transient states to target states</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If the number of target states is greater than or equal to the number of states, or the number of transient\nstates is greater than or equal to the number of states</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Calls the constructor of the parent class AbstractMarkov, with additional attributes.\nThen, initializes the defining parameters and constraints for the reachability problem.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n_states</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_features</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_targets</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_transient</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">pi</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">Q</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">R</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "markovml.markovml.MarkovReach.n_targets", "modulename": "markovml.markovml", "qualname": "MarkovReach.n_targets", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "markovml.markovml.MarkovReach.n_transient", "modulename": "markovml.markovml", "qualname": "MarkovReach.n_transient", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "markovml.markovml.MarkovReach.get_values", "modulename": "markovml.markovml", "qualname": "MarkovReach.get_values", "kind": "function", "doc": "<p>Returns the values of pi, Q, R, v, features, and ml_outputs as a dictionary.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dict</strong>: A dictionary with keys:\n<ul>\n<li><code>pi</code>: the values of pi</li>\n<li><code>Q</code>: the values of Q</li>\n<li><code>R</code>: the values of R</li>\n<li><code>v</code>: the values of v</li>\n<li><code>features</code>: the values of the features</li>\n<li><code>ml_outputs</code>: the values of the ml_outputs</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.markovml.MarkovReach.pi", "modulename": "markovml.markovml", "qualname": "MarkovReach.pi", "kind": "variable", "doc": "<p>Accessor for the pi parameter.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>gurobipy.tupledict</strong>: The pi parameter</li>\n</ul>\n"}, {"fullname": "markovml.markovml.MarkovReach.Q", "modulename": "markovml.markovml", "qualname": "MarkovReach.Q", "kind": "variable", "doc": "<p>Accessor for the Q parameter.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>gurobipy.tupledict</strong>: The Q parameter</li>\n</ul>\n"}, {"fullname": "markovml.markovml.MarkovReach.R", "modulename": "markovml.markovml", "qualname": "MarkovReach.R", "kind": "variable", "doc": "<p>Accessor for the R parameter.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>gurobipy.tupledict</strong>: The R parameter</li>\n</ul>\n"}, {"fullname": "markovml.markovml.MarkovReach.v", "modulename": "markovml.markovml", "qualname": "MarkovReach.v", "kind": "variable", "doc": "<p>Accessor for the v parameter.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>gurobipy.tupledict</strong>: The v parameter</li>\n</ul>\n"}, {"fullname": "markovml.markovml.MarkovReach.set_pi", "modulename": "markovml.markovml", "qualname": "MarkovReach.set_pi", "kind": "function", "doc": "<p>Helper function to set the entire pi vector.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>values</strong> (List[float | int | gp.Var | gp.LinExpr]):\nThe values to set the pi parameter to</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If the values have incorrect length, are not in [0, 1], don't sum to &lt;=1, or pi is already set</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>This checks for validity of the values, checks if pi is already set, and sets the values.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">Var</span> <span class=\"o\">|</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">LinExpr</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.markovml.MarkovReach.set_Q", "modulename": "markovml.markovml", "qualname": "MarkovReach.set_Q", "kind": "function", "doc": "<p>Helper function to set the Q matrix.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>values</strong> (List[List[float | int | gp.Var | gp.LinExpr]]):\nThe values to set the Q matrix to</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If the values have incorrect length, are not in [0, 1), rows don't sum to strictly less than 1, or Q is already set</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>This checks for validity of the values, checks if Q is already set, and sets the values.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">Var</span> <span class=\"o\">|</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">LinExpr</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.markovml.MarkovReach.set_R", "modulename": "markovml.markovml", "qualname": "MarkovReach.set_R", "kind": "function", "doc": "<p>Helper function to set the R matrix.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>values</strong> (List[List[float | int | gp.Var | gp.LinExpr]]):\nThe values to set the R matrix to</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If the values have incorrect length, are not in [0, 1], rows don't sum to &lt;=1, or R is already set</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>This checks for validity of the values, checks if R is already set, and sets the values.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">Var</span> <span class=\"o\">|</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">LinExpr</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.markovml.MarkovHitting", "modulename": "markovml.markovml", "qualname": "MarkovHitting", "kind": "class", "doc": "<p>For the hitting time problem.</p>\n", "bases": "AbstractMarkov"}, {"fullname": "markovml.markovml.MarkovHitting.__init__", "modulename": "markovml.markovml", "qualname": "MarkovHitting.__init__", "kind": "function", "doc": "<p>Initialize a Markov chain for the hitting time problem.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>n_states</strong> (int):\nThe number of states</li>\n<li><strong>n_features</strong> (int):\nThe number of features</li>\n<li><strong>n_transient</strong> (int):\nThe number of transient states ($|T|$ in the paper)</li>\n<li><strong>pi</strong> (Optional[List | np.ndarray]):\nThe initial state distribution over transient states</li>\n<li><strong>Q</strong> (Optional[List[List] | np.ndarray]):\nThe transition matrix between transient states</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If the number of transient states is greater than or equal to the number of states</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Calls the constructor of the parent class AbstractMarkov, with additional attributes.\nThen, initializes the defining parameters and constraints for the hitting time problem.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n_states</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_features</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_transient</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">pi</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">Q</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "markovml.markovml.MarkovHitting.n_transient", "modulename": "markovml.markovml", "qualname": "MarkovHitting.n_transient", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "markovml.markovml.MarkovHitting.get_values", "modulename": "markovml.markovml", "qualname": "MarkovHitting.get_values", "kind": "function", "doc": "<p>Returns the values of pi, Q, v, features, and ml_outputs as a dictionary.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dict</strong>: A dictionary with keys:\n<ul>\n<li><code>pi</code>: the values of pi</li>\n<li><code>Q</code>: the values of Q</li>\n<li><code>v</code>: the values of v</li>\n<li><code>features</code>: the values of the features</li>\n<li><code>ml_outputs</code>: the values of the ml_outputs</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.markovml.MarkovHitting.pi", "modulename": "markovml.markovml", "qualname": "MarkovHitting.pi", "kind": "variable", "doc": "<p>Accessor for the pi parameter.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>gurobipy.tupledict</strong>: The pi parameter</li>\n</ul>\n"}, {"fullname": "markovml.markovml.MarkovHitting.Q", "modulename": "markovml.markovml", "qualname": "MarkovHitting.Q", "kind": "variable", "doc": "<p>Accessor for the Q parameter.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>gurobipy.tupledict</strong>: The Q parameter</li>\n</ul>\n"}, {"fullname": "markovml.markovml.MarkovHitting.v", "modulename": "markovml.markovml", "qualname": "MarkovHitting.v", "kind": "variable", "doc": "<p>Accessor for the v parameter.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>gurobipy.tupledict</strong>: The v parameter</li>\n</ul>\n"}, {"fullname": "markovml.markovml.MarkovHitting.set_pi", "modulename": "markovml.markovml", "qualname": "MarkovHitting.set_pi", "kind": "function", "doc": "<p>Helper function to set the entire pi vector.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>values</strong> (List[float | int | gp.Var | gp.LinExpr]):\nThe values to set the pi parameter to</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If the values have incorrect length, are not in [0, 1], don't sum to &lt;=1, or pi is already set</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>This checks for validity of the values, checks if pi is already set, and sets the values.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">Var</span> <span class=\"o\">|</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">LinExpr</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.markovml.MarkovHitting.set_Q", "modulename": "markovml.markovml", "qualname": "MarkovHitting.set_Q", "kind": "function", "doc": "<p>Helper function to set the Q matrix.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>values</strong> (List[List[float | int | gp.Var | gp.LinExpr]]):\nThe values to set the Q matrix to</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If the values have incorrect length, are not in [0, 1), rows don't sum to strictly less than 1, or Q is already set</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>This checks for validity of the values, checks if Q is already set, and sets the values.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">Var</span> <span class=\"o\">|</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">LinExpr</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.utils", "modulename": "markovml.utils", "kind": "module", "doc": "<p>This module contains several utilities that are necessary and useful for building Markov processes with learned parameters.</p>\n\n<p>In <code>gurobi_ml_ext</code>, we extend the Gurobi machine learning functionality to work with additional models, namely classifiers with softmax outputs.</p>\n\n<p>In <code>models_ext</code>, we contain some additional \"models\" that we have implemented for convenience, namely <code>DecisionRules</code> which allows the user to specify \"if-then\" statements in natural language, and <code>SequentialClassifier</code>, which is a wrapper for a PyTorch <code>nn.Sequential</code> model that adds a softmax layer at the end of it.</p>\n\n<p>In <code>ima</code>, we contain all the functions necessary for <em>interval matrix analysis</em>, culminating in the implementation of the interval version of the Gauss-Seidel method.</p>\n"}, {"fullname": "markovml.utils.gurobi_ml_ext", "modulename": "markovml.utils.gurobi_ml_ext", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "markovml.utils.gurobi_ml_ext.add_mlp_classifier_constr", "modulename": "markovml.utils.gurobi_ml_ext", "qualname": "add_mlp_classifier_constr", "kind": "function", "doc": "<p>Encodes an MLPClassifier in a Gurobi model by manually implementing softmax activation.\nUses Gurobi's nonlinear functions to implement softmax.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>model</strong> (gp.Model):\nModel to add constraints to</li>\n<li><strong>clf</strong> (MLPClassifier):\nClassifier to add constraints for</li>\n<li><strong>input_vars</strong> (List[gp.Var]):\nVariables corresponding to features</li>\n<li><strong>output_vars</strong> (List[gp.Var]):\nVariables to store probabilities (e.g., P[0,:])</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_model</span><span class=\"o\">.</span><span class=\"n\">Model</span>,</span><span class=\"param\">\t<span class=\"n\">clf</span><span class=\"p\">:</span> <span class=\"n\">sklearn</span><span class=\"o\">.</span><span class=\"n\">neural_network</span><span class=\"o\">.</span><span class=\"n\">_multilayer_perceptron</span><span class=\"o\">.</span><span class=\"n\">MLPClassifier</span>,</span><span class=\"param\">\t<span class=\"n\">input_vars</span>,</span><span class=\"param\">\t<span class=\"n\">output_vars</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.utils.gurobi_ml_ext.add_decision_tree_classifier_constr", "modulename": "markovml.utils.gurobi_ml_ext", "qualname": "add_decision_tree_classifier_constr", "kind": "function", "doc": "<p>Encodes a DecisionTreeClassifier in a Gurobi model.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>model</strong> (gp.Model):\nModel to add constraints to</li>\n<li><strong>clf</strong> (DecisionTreeClassifier):\nClassifier to add constraints for</li>\n<li><strong>input_vars</strong> (List[gp.Var]):\nVariables corresponding to features</li>\n<li><strong>output_vars</strong> (List[gp.Var]):\nVariables to store outputs (e.g., P[0,:])</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_model</span><span class=\"o\">.</span><span class=\"n\">Model</span>,</span><span class=\"param\">\t<span class=\"n\">clf</span><span class=\"p\">:</span> <span class=\"n\">sklearn</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">_classes</span><span class=\"o\">.</span><span class=\"n\">DecisionTreeClassifier</span>,</span><span class=\"param\">\t<span class=\"n\">input_vars</span>,</span><span class=\"param\">\t<span class=\"n\">output_vars</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.utils.gurobi_ml_ext.add_random_forest_classifier_constr", "modulename": "markovml.utils.gurobi_ml_ext", "qualname": "add_random_forest_classifier_constr", "kind": "function", "doc": "<p>Encodes a RandomForestClassifier in a Gurobi model.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>model</strong> (gp.Model):\nModel to add constraints to</li>\n<li><strong>clf</strong> (RandomForestClassifier):\nClassifier to add constraints for</li>\n<li><strong>input_vars</strong> (List[gp.Var]):\nVariables corresponding to features</li>\n<li><strong>output_vars</strong> (List[gp.Var]):\nVariables to store outputs (e.g., P[0,:])</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_model</span><span class=\"o\">.</span><span class=\"n\">Model</span>,</span><span class=\"param\">\t<span class=\"n\">clf</span><span class=\"p\">:</span> <span class=\"n\">sklearn</span><span class=\"o\">.</span><span class=\"n\">ensemble</span><span class=\"o\">.</span><span class=\"n\">_forest</span><span class=\"o\">.</span><span class=\"n\">RandomForestClassifier</span>,</span><span class=\"param\">\t<span class=\"n\">input_vars</span>,</span><span class=\"param\">\t<span class=\"n\">output_vars</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.utils.gurobi_ml_ext.add_decision_rules_constr", "modulename": "markovml.utils.gurobi_ml_ext", "qualname": "add_decision_rules_constr", "kind": "function", "doc": "<p>Add constraints to encode decision rules in a Gurobi model.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>model</strong> (gp.Model):\nGurobi model to add constraints to</li>\n<li><strong>rules</strong> (DecisionRules):\nFitted DecisionRules object</li>\n<li><strong>input_vars</strong> (List[gp.Var]):\nInput variables corresponding to features</li>\n<li><strong>output_vars</strong> (List[gp.Var]):\nOutput variables (note that only one output variable is supported for now)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If DecisionRules is not fitted or if there is more than one output variable</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Uses a series of logical implications to encode the rules. Note that the encoding makes\nit so that the first rule that an input satisfies is the one that is used.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_model</span><span class=\"o\">.</span><span class=\"n\">Model</span>,</span><span class=\"param\">\t<span class=\"n\">rules</span><span class=\"p\">:</span> <span class=\"n\">markovml</span><span class=\"o\">.</span><span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">models_ext</span><span class=\"o\">.</span><span class=\"n\">DecisionRules</span>,</span><span class=\"param\">\t<span class=\"n\">input_vars</span>,</span><span class=\"param\">\t<span class=\"n\">output_vars</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.utils.gurobi_ml_ext.add_sequential_classifier_constr", "modulename": "markovml.utils.gurobi_ml_ext", "qualname": "add_sequential_classifier_constr", "kind": "function", "doc": "<p>Encodes a SequentialClassifier in a Gurobi model by manually implementing softmax activation.\nSequentialClassifier is a wrapper around a PyTorch Sequential model that adds a final softmax layer.\nUses Gurobi's nonlinear functions to implement softmax.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>model</strong> (gp.Model):\nModel to add constraints to</li>\n<li><strong>clf</strong> (SequentialClassifier):\nClassifier to add constraints for</li>\n<li><strong>input_vars</strong> (List[gp.Var]):\nVariables corresponding to features</li>\n<li><strong>output_vars</strong> (List[gp.Var]):\nVariables to store probabilities (e.g., P[0,:])</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">gurobipy</span><span class=\"o\">.</span><span class=\"n\">_model</span><span class=\"o\">.</span><span class=\"n\">Model</span>,</span><span class=\"param\">\t<span class=\"n\">clf</span><span class=\"p\">:</span> <span class=\"n\">markovml</span><span class=\"o\">.</span><span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">models_ext</span><span class=\"o\">.</span><span class=\"n\">SequentialClassifier</span>,</span><span class=\"param\">\t<span class=\"n\">input_vars</span>,</span><span class=\"param\">\t<span class=\"n\">output_vars</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.utils.ima", "modulename": "markovml.utils.ima", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "markovml.utils.ima.negate", "modulename": "markovml.utils.ima", "qualname": "negate", "kind": "function", "doc": "<p>Negate an interval matrix A: -[a,b] = [-b,-a]</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">A</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.utils.ima.add", "modulename": "markovml.utils.ima", "qualname": "add", "kind": "function", "doc": "<p>Add two interval matrices: [a,b] + [c,d] = [a+c, b+d]</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">B</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.utils.ima.subtract", "modulename": "markovml.utils.ima", "qualname": "subtract", "kind": "function", "doc": "<p>Subtract interval matrices using A - B = A + (-B)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">B</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.utils.ima.multiply", "modulename": "markovml.utils.ima", "qualname": "multiply", "kind": "function", "doc": "<p>Multiply interval matrices: products of all combinations, then take min/max</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">B</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.utils.ima.intersect_intervals", "modulename": "markovml.utils.ima", "qualname": "intersect_intervals", "kind": "function", "doc": "<p>Intersect two interval matrices</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">B</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.utils.ima.interval_gauss_seidel", "modulename": "markovml.utils.ima", "qualname": "interval_gauss_seidel", "kind": "function", "doc": "<p>Gauss-Seidel iteration using interval arithmetic.</p>\n\n<p>Args:\n    A: Interval matrix (n x n x 2)\n    b: Interval vector (n x 2)\n    x0: Initial guess (n x 2)\n    max_iter: Maximum iterations\n    tol: Convergence tolerance</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">x0</span>, </span><span class=\"param\"><span class=\"n\">max_iter</span><span class=\"o\">=</span><span class=\"mi\">10</span>, </span><span class=\"param\"><span class=\"n\">tol</span><span class=\"o\">=</span><span class=\"mf\">1e-06</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.utils.ima.inverse", "modulename": "markovml.utils.ima", "qualname": "inverse", "kind": "function", "doc": "<p>Compute interval matrix inverse using Gauss-Seidel iteration.</p>\n\n<p>Args:\n    A: Interval matrix (n x n x 2)\n    max_iter: Maximum iterations for Gauss-Seidel\n    tol: Convergence tolerance</p>\n\n<p>Returns:\n    Inverse interval matrix (n x n x 2)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">A</span>, </span><span class=\"param\"><span class=\"n\">max_iter</span><span class=\"o\">=</span><span class=\"mi\">100</span>, </span><span class=\"param\"><span class=\"n\">tol</span><span class=\"o\">=</span><span class=\"mf\">1e-06</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "markovml.utils.models_ext", "modulename": "markovml.utils.models_ext", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "markovml.utils.models_ext.DecisionRules", "modulename": "markovml.utils.models_ext", "qualname": "DecisionRules", "kind": "class", "doc": "<p>Decision rules is a \"model\" that is a set of rules.\nIt implements a series of if-then rules, and an else rule.\nIt can be used to encode simple decision rules as are found\nin the the literature. E.g., \"if age &gt; 65 then mortality risk\nis 10%\".</p>\n\n<p>Example:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">features</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;age&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;income&#39;</span><span class=\"p\">]</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">DecisionRules</span><span class=\"p\">(</span><span class=\"n\">features</span><span class=\"p\">)</span>\n<span class=\"n\">rules</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"s2\">&quot;if age &gt; 20 then 2.5&quot;</span><span class=\"p\">,</span>\n    <span class=\"s2\">&quot;if income &gt;= 50000 and age &lt; 30 then -1.0&quot;</span><span class=\"p\">,</span>\n    <span class=\"s2\">&quot;else 0.0&quot;</span>\n<span class=\"p\">]</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">rules</span><span class=\"o\">=</span><span class=\"n\">rules</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>You can then use the model to make predictions:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">X</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">25</span><span class=\"p\">,</span> <span class=\"mi\">60000</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">19</span><span class=\"p\">,</span> <span class=\"mi\">30000</span><span class=\"p\">]])</span>\n<span class=\"n\">predictions</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">predict</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>The first row is 2.5, the second row is 0.0.</p>\n"}, {"fullname": "markovml.utils.models_ext.DecisionRules.__init__", "modulename": "markovml.utils.models_ext", "qualname": "DecisionRules.__init__", "kind": "function", "doc": "<p>Initialize the DecisionRules model.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>features</strong> (list of str):\nThe features that the model will use. E.g., ['age', 'income'].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">features</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "markovml.utils.models_ext.DecisionRules.features", "modulename": "markovml.utils.models_ext", "qualname": "DecisionRules.features", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "markovml.utils.models_ext.DecisionRules.fit", "modulename": "markovml.utils.models_ext", "qualname": "DecisionRules.fit", "kind": "function", "doc": "<p>Fits the DecisionRules model to the provided rules.</p>\n\n<p>The rules are specified in natural language format, with each rule being\na string like \"if age &gt; 20 then 2.5\".</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>rules</strong> (list of str):\nThe rules to compile. Each rule should be in the format\n\"if <condition> then <value>\" or \"else <value>\".</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>DecisionRules</strong>: The fitted model instance.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If any of the following conditions are met:\n<ul>\n<li>Multiple else clauses are found</li>\n<li>The else clause is not the last rule</li>\n<li>No rules are provided</li>\n<li>A rule contains an operator other than &gt;, &gt;=, &lt;, &lt;=, ==</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">rules</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">markovml</span><span class=\"o\">.</span><span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">models_ext</span><span class=\"o\">.</span><span class=\"n\">DecisionRules</span>:</span></span>", "funcdef": "def"}, {"fullname": "markovml.utils.models_ext.DecisionRules.predict", "modulename": "markovml.utils.models_ext", "qualname": "DecisionRules.predict", "kind": "function", "doc": "<p>Make predictions using the compiled rules.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (np.ndarray or List[dict]):\nThe input data.\n<ul>\n<li>If a numpy array, it is assumed to be a 2D array where each row is\nan entry, in the order of the features passed at initialization.</li>\n<li>If a list of dictionaries, each key is a feature name, and the\nvalue is the feature value.</li>\n</ul></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: The predictions for each input row.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "markovml.utils.models_ext.SequentialClassifier", "modulename": "markovml.utils.models_ext", "qualname": "SequentialClassifier", "kind": "class", "doc": "<p>Wrapper class that adds a Softmax layer to a Sequential model</p>\n", "bases": "torch.nn.modules.container.Sequential"}, {"fullname": "markovml.utils.models_ext.SequentialClassifier.__init__", "modulename": "markovml.utils.models_ext", "qualname": "SequentialClassifier.__init__", "kind": "function", "doc": "<p>Initialize internal Module state, shared by both nn.Module and ScriptModule.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sequential</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">modules</span><span class=\"o\">.</span><span class=\"n\">container</span><span class=\"o\">.</span><span class=\"n\">Sequential</span></span>)</span>"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();